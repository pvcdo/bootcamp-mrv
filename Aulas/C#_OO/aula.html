<h1>Programando com Orientação a Objeto com C#</h1>

<p>Professor Leonardo Buta - tem um canal no youtube: Leonardo Buta</p>

<h2>Conhecendo a Programação Orientada a Objetos</h2>

<h3>Apresentando a programação orientada a objetos</h3>

<p>É um paradigma de programação, uma técnica, uma maneira de fazer programação. Esse paradigma tenta aproximar o mundo real da programação, pois tenta abstrair o mundo real dentro do código.</p>

<ul>
    Os pilares são:
    <li>Abstração</li>
    <li>Encapsulamento</li>
    <li>Herança</li>
    <li>Polimorfismo</li>
</ul>

<p>Os pilares são independentes e harmônicos, com exceção do polimorfismo que depende de herança.</p>

<p>Os principais conceitos da POO são as classes e objetos. Uma classe é um molde e um objeto é algo criado a partir desse molde.</p>

<h3>Tipos de paradigmas</h3>

<p>Existem vários de paradigmas, dentre os quais destacam-se:</p>

<ul>
    <li>POO</li>
    <LI>Estruturada</LI>
    <li>Imperativa</li>
    <li>Procedural</li>
    <li>Orientada a eventos</li>
    <li>Lógica</li>
</ul>

<a href="https://docs.microsoft.com/pt-br/dotnet/csharp/fundamentals/tutorials/oop">POO C# by Microsoft.</a>

<h2>Abstração</h2>

<h3>Introdução</h3>

<p>Representar um objeto do mundo real considerando apenas os atributos importantes para o projeto. Por exemplo, uma criança que está em fase escolar tem diversas características, mas para um sistema informático de orientação a objetos da sua escola, o importante é o número da matrícula dela, as suas notas, faltas, nome, sala, série, dentre outros que fazem sentido no contexto da escola.</p>

<h2>Encapsulamento</h2>

<h3>Introdução</h3>

<p>Proteger elementos de uma classe e definir os limites de sua alteração. Também serve para ocultar ou expor um comportamento se necessário, deixando a aplicação mais segura contra alterações equivocadas.</p>

<p>Indica que um atributo ou método só é acessível dentro da classe, sendo que para modificar ou atuar nessa propriedade deve-se passar por um método que seja público.</p>

<p>O encapsulamento está diretamente ligado a modificadores de acesso (public, private, internal, protected, etc...).</p>

<h2>Herança</h2>

<p>Também um dos pilares da POO. Permite reutilizar atributos, métodos e comportamentos de outra classe.</p>

<p>É como se copiássemos os atributos e métodos da classe pai e os colássemos nas classes filhas.</p>

<h2>Polimorfismo</h2>

<p>Podemos sobrescrever um método herdado por uma filha de uma classe pai, fazendo com que seu comportamento seja mais adequado e específico para aquela filha.</p>

<h3>Em tempo de compilação (overload/early binding)</h3>

<p>Dentro de uma classe podemos criar dois métodos com o mesmo nome, tendo os dois assinaturas diferentes.</p>

<p>Exemplo</p>

<img src="./img/pilar-polimorfismo-compilacao.PNG" alt="">

<h3>Em tempo de execução (oerride/late binding)</h3>

<p>É a sobrescrita de um método de uma classe pai por uma classe filha. Essa sobrescrita acontece dentro do contexto da filha.</p>

<p>Exemplo</p>

<img src="img/pilar-polimorfismo-execucao.PNG" alt="">

<p>Interessante notar que no exemplo de polimorfismo em tempo de execução acima, temos que colocar o tipo virtual na classe pai e override no método herdado na classe filha, esses dois adjetivos devem estar junto do tipo do método (void, por exemplo).</p>

<h2>Classes abstratas</h2>

<p>É um conceito fortemente ligado a heranças. Elas tem apenas a função de ser pai, não podemos instanciar um objeto com base nela, mas apenas criar outras classes herdando suas propriedades. Os métodos também podem ser classificados como abstratos, sendo que métodos abstratos devem ser obrigatoriamente sobrescritos por meio do polimorfismo em tempo de execução.</p>

<h2 id="cs_oo-classes-seladas">Classes seladas</h2>

<p>Ao contrário da abstrata ela não pode ter classes filhas. Métodos e atributos também podem ser selados. No caso de métodos não se pode fazer polimorfismo daqueles que são selados. Nenhuma classe pode herdar propriedades de uma classe selada.</p>

<p>Para marcar uma classe, método ou atributo como selada temos que passar o adjetivo &lt;&lt;sealed&gt;&gt;. <span style="color: red;">Lembrando que os adjetivos são passados antes do nome da classe ou propriedade.</span></p>

<p>Classes seladas podem herdar, não podem passar herança.</p>

<h2>Classe object</h2>

<p>A classe System.Object é a mãe de todas as classes .NET. Todas as classes derivam direta ou indiretamente dessa classe Object. Ela tem por objetivo prover serviços de baixo nível para as suas filhas.</p>

<p>É possível sobrescrever alguns métodos da classe System.Object</p>

<h2>Interfaces</h2>

<p>Interface é um contrato que pode ser implementado por uma classe. Não pode ser instanciada diretamente assim como a classe abstrata. A diferença entre classe e interface é que uma classe só pode herdar props de apenas de uma classe, mas pode herdar props de inúmeras interfaces.</p>

<p>Caso um método na interface não tenha uma lógica associada ("uma implementação padrão") esse método deve obrigatoriamente receber uma lógica ("ser implementado") na classe que herda ("implementa") essa interface; caso ele tenha uma implementação padrão eu posso optar em sobrescrever (implementar) ou não este método na classe que herda a interface. Esse tipo de comportamento se deu a partir do C# 8, antes não era possível fazer implementação padrão de métodos em interfaces.</p>

<h2>Manipular arquivos</h2>

<p>A seguir classes estáticas para trabalho com arquivos, pastas e rotas:</p>

<ul>
    <li>Directory</li>
    <li>File</li>
    <li>Path</li>
</ul>

<p>O acesso a essas classes é possível a partir do uso do namespace System.IO. O uso do namespace significa escrever "using 'nome do namespace'" no início do documento.</p> 

<p>Classes estáticas não são instanciáveis, ou seja, nós as usamos diretamente.</p>

<h3>Directory</h3>

<ul>
    <li>
        Directory.GetDirectories()
        <ul>
            <li>
                <p>Directory.GetDirectories(diretorio_raiz) - retorna um array com os subdiretórios presentes no diretorio_raiz.</p>
            </li>
            <li>
                <p>Directory.GetDirectories(diretorio_raiz,"*",SearchOption.AllDirectories) - retorna um array com todos os subdiretórios abaixo do diretorio_raiz.</p>
            </li>
        </ul>
    </li>
    <li>
        Directory.GetFiles()
        <ul>
            <li>
                <p>Directory.GetFiles(diretorio_raiz) - retorna um array com os arquivos que estão no diretorio_raiz</p>
            </li>
            <li>
                <p>Directory.GetFiles(diretorio_raiz,"*",SearchOption.AllDirectories) - retorna um array com todos os arquivos que estão abaixo do diretorio_raiz</p>
            </li>
            <li>
                <p>Directory.GetFiles(diretorio_raiz,"*.txt",SearchOption.AllDirectories) - retorna um array com todos os arquivos txt que estão abaixo do diretorio_raiz</p>
            </li>
        </ul>
    </li>
    <li>
        Directory.CreateDirectory()
        <ul>
            <li>
                <p>Directory.CreateDirectory(caminho) - cria um diretório baseado no caminho passado e retorna informações sobre o diretório criado.</p>
                <ul>
                    <li>
                        <p>Uma das informações retornadas é o FullName que passa o path completo do diretório criado.</p>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>
        Directory.Delete()
        <ul>
            <li>
                <p>Directory.Delete(caminho) - exclusão de pasta sem arquivos e subpastas</p>
            </li>
            <li>
                <p>Directory.Delete(caminho, bool apagarFilhos) - caso o diretório tenha arquivos ou subpastas, temos que passar o segundo pâmetro como true para apagar tudo.</p>
                <p>Essa exclusão é definitiva, ou seja, o arquivo deletado não vai para a lixeira, ele é excluído do HD (da memória).</p>
            </li>
        </ul>
    </li>
</ul>

<p style="color:red">Nos métodos listados acima, o asterisco indica que a busca do texto vai admitir qualquer sequência de caracteres.</p>

<h3>File</h3>

<ul>
    <li>
        File.WriteAllText(caminho, conteudo) - esse método cria um arquivo com o nome e no diretório especificado no 'caminho' e com o conteúdo especificado em 'conteudo'. Caso o arquivo já exista ele é sobrescrito, portanto, convém colocar um condicional para contornar essa sobrescrição no método.
    </li>
    <li>
        File.CreateText(caminho) - retorna um objeto do tipo StreamWriter que consiste
        File.WriteAllText(caminho, conteudo)
    </li>
    <li>
        File.CreateText(caminho) - retorna um objeto StreamWrite para que eu vá escrevendo aos poucos um documento.
    </li>
    <li>
        <p>File.AppendAllText(caminho, conteudo) - abre um arquivo, adiciona o conteúdo (string) passado e fecha o arquivo. Cria um novo arquivo caso o que estamos referenciando ainda não exista.</p>
    </li>
    <li>
            <pre>
                public void funcao(string caminho, List&lt;string&gt; conteudo)
                {
                    using(var stream = File.AppendText(caminho))
                    {
                        foreach(var linha in conteudo)
                        {
                            stream.WriteLine(linha);
                        }
                    }
                }
            </pre>
        <p>Tal qual o CreateText, o AppendText usa gera um objeto StreamWriter o qual irá operar a escrita de anexos ao documento já existente.</p>
    </li>
    <li>
        Leitura de um arquivo sem stream
        <p>File.ReadAllLines(caminho) - retorna um array de strings, sendo cada item o array uma linha do arquivo.</p>
    </li>
    <li>
        Leitura de arquivo com stream
        <pre>
            public void funcao(string caminho)
            {
                // var linha = string.Empty; //não sei por que usar essa variável
                using(var stream = File.OpenText(caminho))
                {
                    while((linha = stream.ReadLine()) != null) 
                    //while(stream.ReadLine() != null) //acredito dar o mesmo resultado que o com o while acima
                    {
                        System.Console.WriteLine(linha);
                    }
                }
            }
        </pre>
        <p>O OpenText gera um StreamReader para que possamos ir lendo cada linha de forma pausada, não a leitura inteira do documento de uma vez.</p>
    </li>
    <li>
        <p>Movendo um arquivo</p>
        File.Move(caminho_velho, caminho_novo) - podemos no caminho novo também escolher um novo nome para o arquivo. Inicilmente não é permitido que no caminho novo tenha um arquivo de mesmo nome, mas podemos passar um terceiro parâmetro para o método, permitindo que haja sobrescrita no novo caminho.
    </li>
    <li>
        <p>Copiando um arquivo</p>
        <p>File.Copy(caminho_velho, caminho_novo) - podemos no caminho novo também escolher um novo nome para o arquivo. Inicilmente não é permitido que no caminho novo tenha um arquivo de mesmo nome, mas podemos passar um terceiro parâmetro para o método, permitindo que haja sobrescrita no novo caminho.</p>
    </li>
    <li>
        <p>Deletando um arquivo</p>
        <p>File.Delete(caminho) - esse método é irreversível, ele é apagado da memória.</p>
    </li>
</ul>

<h3>Path</h3>

<ul>
    <li>
        Path.Combine(caminho, pasta, subpasta, subsubpasta, [nome do arquivo com extensão] ...) - cria uma string do caminho para ser utilizada.
    </li>
</ul>