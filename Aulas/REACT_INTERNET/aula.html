<h1>Desenvolvimento de aplicações para internet com ReactJS</h1>

<a href="https://github.com/eduardogc/digital-one-react-intermediario">GitHub da aula do professor</a>

<h2>Estilização de componentes</h2>

<p>Há três maneiras de estilizar elementos no ReactJS.</p>

<ul>
    <li>Inline</li>
    <li>Classes</li>
    <li>CSS in JS</li>
</ul>

<h3>Inline</h3>

<p>Exs.:</p>
<img src="img/estilo-inline.PNG" alt="">
<img src="img/estilo-inline2.PNG" alt="">

<p>Vantagens</p>
<ul>
    <li>Maneira mais prática</li>
    <li>Ajustes rápidos</li>
    <li>Testes de estilo</li>
</ul>

<p>Desvantagens</p>

<ul>
    <li>Difícil manutenção.</li>
</ul>

<h3>Classes</h3>

<img src="img/estilo-classes.PNG" alt="">

<p>Vantagens</p>
<ul>
    <li>Maneira mais prática e direta</li>
</ul>

<p>Desvantagens</p>
<ul>
    <li>Difícil manutenção</li>
    <li>Pouca flexibilidade</li>
    <li>Conflitos com nomes</li>
</ul>

<h3>CSS in JS</h3>

<p>O próprio JavaScript gera CSS para nós. O método mais utilizado é através do styled-components</p>

<p>Vantagens</p>
<ul>
    <li>Facilidade de remover css</li>
    <li>Estilos dinâmicos</li>
    <li>Performance</li>
    <li>Injeção automática de prefixos vendor (-moz, -webkit, etc)</li>
</ul>

<h2>Stateful vs Stateless</h2>

<p>Stateful usa estados, ou seja, tem o useState no código; stateless não utiliza.</p>

<H2>Formulários no ReactJS</H2>

<h3>Componente controlado</h3>

<p>Select, input ou textarea aceitam o atributo value e nós podemos mudá-lo usando o atributo onChange. Os estados são utilizados para definir as ações do projeto.</p>

<h3>Componente não controlado</h3>

<p>Usado para inputs read-only, como envio de arquivos. O react orienta usar todos o máximo de componentes controlados possível.</p>

<a href="https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/"></a>

<p>É possível usar bibliotecas de form para facilitar o trabalho no REACT. A Formik e o Redux-forms são as mais populares.</p>

<h2>O que é o Flux?</h2>

<p>É uma arquitetura para comunicação entre componetes React. É um padrão de projeto para tráfego de dados de maneira unidirecional.</p>

<h3>Action</h3>

<p>Formata a mensagem a ser enviada. Quando precisamos alterar um estado a action formata a mensagem.</p>

<h3>Dispatcher</h3>

<p>Entrega a mensagem dada pela action à callback correta.</p>

<h3>Store</h3>

<p>Guarda todos os estados e faz as as alterações.</p>

<h3>View</h3>

<p>"Middleware" entre a store e a tela, vê as alterações e solicita a atualização da tela (o react por exemplo é a camada de view).</p>

<p>Redux é implementação mais popular de flux.</p>

<h2>O que é o Redux?</h2>

<p>Criado por Dan Abramov e Andrew Clark em 2015.</p>

<img src="img/redux.PNG" alt="">

<p>Diferentemente do flux raíz, não tem o dispatcher e tem também o componente chamado de reducer. A camada de view no esquema foi chamada de React.</p>

<p>No flux tem várias stores. No redux apenas um. O State é read-only e as mudanção são feitas por pure functions (estado imutável).</p>

<h3>Actions</h3>

<p>São como as do flux, mas com uma direrença, não enviam a action ao dispatcher (que não existe), mas retornam um objeto action formatado.</p>

<h3>Store</h3>

<p>Cuida de toda a árvore de estados.</p>

<h3>Reducer</h3>

<p>Pega o estado da store e o divide para pequenos reducers descobrirem como lidar com ele.</p>

<h3>Views</h3>

<p>Utilizando o React temos 3 conceitos de conexão da view com o store</p>

<ul>
    <li>Provider - wrapper da árvore de componentes. Tornar mais fácil a conexão dos filhos à Store a partir do connect.</li>
    <li>connect() - é uma função do react-redux. Se um comp deseja pegar os updates do estado ele usa a função connect()</li>
    <li>selector - a conexão do comp é feita utilizando o selector, que é uma função escrita por nós indicando quais estados do redux que queremos passar como props.</li>
</ul>

<h2>Prática com Redux</h2>

<p>É preciso dar <b>npm i react-redux</b> e <b>npm i --save-dev redux-devtools</b> para trabalhar com o redux no react. Nós também temos que instalar a extensão <b>Redux DevTools</b></p>

<p>O professor usou o projeto contador da <a href="https://github.com/eduardogc/digital-one-react-intermediario/tree/master/src/aula-2">aula 2</a>, além do index.js e a pasta redux da <a href="https://github.com/eduardogc/digital-one-react-intermediario/tree/master/src">src</a>.</p>

<p>Podemos ver no projeto da aula a utilização do provider, actions, reducers, connect, entre outros conceitos passados nas aulas desta seção de redux.</p>

<p>Ao clicar nos botões nós podemos abrir o inspetor do google e ir na aba Redux para fazer a análise do react.</p>

<h2>Rest HTTP com React</h2>

<p>Nativamente nós temos o fetch api e tem a lib externa axios.</p>

<p>Servem para conectar um ou mais servidores HTTP. Têm os seguintes métodos:</p>

<ul>
    <li>GET - para listagem</li>
    <li>post criacao</li>
    <li>delete deleção</li>
    <li>put alteracao, algumas patch mas depende do caso</li>
</ul>

<h3>Fetch API</h3>

<ul>
    <li>GET</li>
    <li>post</li>
    <li>delete</li>
    <li>put</li>
</ul>

<p>A fetch api é uma alternativa ao XMLHttpRequest()  ao jQuery.ajax(). Suporte a service workers. Não envia ou recebe cookies. Não rejeito o status do erro HTTP (nem se for 404, nem 500).</p>

<p>A resposta inicial do fetch é por padrão uma promise pending, portanto, temos que passar duas then, sendo que a primeira nós parseamos para json a resposta.</p>

<p>No exemplo de delete e de put, api tem que estar configurada para conseguir acessar os dados pela url.</p>

<H3>Axios</H3>

<p>É cross-browser, pois é baseada no XMLHttpRequest(). Pode monitorar o processo de um request. Melhor tratamento de erros e testes.</p>

<p>Para usar o axios tem que instalar por npm ou yarn.</p>

<ul>
    <li>GET</li>
    <li>post</li>
    <li>delete</li>
    <li>put</li>
</ul>

<p>No axios, como pode ser visto no exemplo do get, a promise já vem resolvida, então conseguimos já pegar o dado ou tratar o erro.</p>

<h3>Exemplos do professor</h3>

<p><a href="https://github.com/eduardogc/digital-one-react-intermediario/blob/master/src/aula-3/Components/Topico1.jsx">fetch-api .get</a> (linha 22).</p>

<h2>Imutabilidade e Redux</h2>

<h3>Pilares da imutabilidade</h3>

<p>Coleção é uma unidade ou um conjunto (um array).</p>

<ul>
    <li>uma vez criada, uma coleção não pode ser alterada</li>
    <li>novas coleções podem ser criadas baseadas e uma coleção anterior</li>
    <li>novas coleções são criadas usando o máximo possível da coleção original</li>
</ul>

<p>Usar imutabilidade é importante para ganho de performance. Podemos ter isso com o uso do shouldComponentUpdate ou React.PureComponent</p>

<p>O virtual DOM só vai atualizar o componente quando houver alteração do estado do componente. Utilizando estruturas imutáveis temos controle sobre a rerenderização</p>

<p>Imutabilidade é você criar cópias das variáveis que você quer usar, mas não apenas usar referências, mas sim o spread, por exemplo. O professor também sugeriu a biblioteca Immutable.js, além da Immer, Immutability-helper, Seamless-immutable.</p>

<p>A imutabilidade é pré-requisito no Redux. Redux e react-redux utilizam comparações rasas. O reducer divide a store e o combine reducer checa as mudanças de forma asa, fazendo a interação dos reducers e cria uma nova store a partir desses reducers. Cada um dos componentes é verificado se houve mudanças, caso haja esse componente atualizado é carregado no novo objeto de store.</p>

<p>connect gera componentes que fazem comparação rasa com o estado root. Também faz a verificação de necessidade de re-render.</p>

<h2>Redux + Rest</h2>

<p>Redux middlwares são usados como camadas entre o disparo de uma ação e o momento que ela atinge o reducer.</p>

<p>Sua criação é bem complexa. Nós podemos usar as libs redux-thunk e redux-saga.</p>

<a href="https://github.com/eduardogc/digital-one-react-intermediario/blob/master/src/redux/reducers/cientistas.js">Exemplo reducers</a>

<p><a href="https://github.com/eduardogc/digital-one-react-intermediario/tree/master/src/aula-3/Components/Topico3">"Tópico 3"</a> = Arquivo de fetch (dispatcher) e a forma final de como conectar a app no React-Redux.</p>

<h2>Testes TDD e BDD</h2>

<h3>TDD</h3>

<p>Test-Driven Development (desenvolvimento orientado a testes). Tem por objetivo escrever um código para testar códigos, para antecipar erros a nível de desenvolvimento. Geralmente escrito antes da escrita da funcionalidade.</p>

<p>Primeiro cria-se um código de teste para a funcionalidade que irá quebrar, e depois criamos a funcionalidade. Depois criamos um teste que irá passar e refatoramos.</p>

<ul>
    <li>Teste unitário</li>
    <li>Teste end-to-end (e2e)</li>
</ul>

<p>No teste unitário testa-se as unidades, ou seja, uma função, componente, serviço ou página.</p>

<p>e2e é ponta a ponta, testa o fluxo.</p>

<p>Ferramentas e maneiras diferentes de fazer o unitário e o e2e.</p>

<p>Num teste unitário no jest, nós chamamos o método nativo "describe" que recebe uma string descrevendo o que é o teste e uma função anônima que por sua vez executa o método it que também recebe uma string de descrição indicando o que queremos que aconteça e uma função anônima que executará uma chamada da função que queremos testar (passando seus argumentos ou não) e o método expect que recebe a função chamada e o que deve acontecer para o teste passar. Ex:</p>

<img src="img/jest-ex1.PNG" alt="">
<img src="img/jest-ex2.PNG" alt="">

<p>É importante fazer o teste antes da escrita da funcionalidade para que esta funcionalidade já seja escrita de modo a suportar testes.</p>

<p>Para fazer esses testes no React podemos usar o jest (que já vem embarcada no create-react-app), react-testing-library, shallow, enzyme, chai, mocha, selenium, puppeteer (roda em cima do browser).</p>

<p>Para testar componentes em react temos que usar a react-testing-library, instalando @testing-library/react e @testing-library/jest-dom-extend-expect como --dev</p>

<img src="img/testingLibrary-ex1.PNG" alt="">
<img src="img/testingLibrary-ex2.PNG" alt="">

<p>No exemplo, baseElement é algo relacionado ao render, não ao teste em si.</p>